Parser and lexer:

* Support for parentheses
* Type casts
* Aggregation
* Trinary conditional operator ("?:")
* Allow location specifiers to be attached to constants
* Unicode identifiers and string literals
* Locking / concurrency control
* Make bison parser "pure"
* In string literals, support the "\000" syntax (Octal ASCII
  character) from C89; or perhaps some syntax for specifying Unicode
  code points?
* Error reporting; location of syntax error

Planner:

* Generate implied equalities from the qualifier list
* Avoid Cartesian products, if possible

Executor/Router/Operators:

* Consider writing a specialized allocator for Tuples
* Don't copy WorkItem in the router: have the queue store kind + pointer directly

Network:

* Add an ad-hoc compression method, to avoid resending table names in
  every single packet
  * Have the client and server negotiate that "table 10" means "table
    foo, with schema bar" once, and use that information for the rest
    of the connection

Data types:

* Consider using a variable-size length word for ColString: more
  storage-efficient for short strings, which is the common case (or
  special-case just for network input/output?)

Build system:

* Make use of profile-guided optimization with GCC

APR:

* Report queue performance issue
* Add support for "apr-config --configure"
* Modify queue type to allow variably-sized queue elements, to avoid
  the need to malloc() small queue messages

Broader issues:

* Testing framework
* Error handling: exceptions via longjmp?
* Add a "$LOCALHOST" variable that expands to the network address of
  the evaluating COL instance
  * Complicated by the fact that a machine can have multiple network
    addresses (one per interface + localhost + IPv4 vs. IPv6, etc.)
* Invent something similar to makeNode() from Postgres: infer node
  size from node type tag
* Consider caching per-tuple hash code
* Measure the performance difference between looking up a function
  pointer and doing a table-style lookup (switch statement) for
  functions like datum_equal(), datum_hash()
* Change the node system to work with strict aliasing per C99
* Measure the performance cost of early projection ("column pruning"):
  are there situations in which it might actually be faster to have
  joins emit a "super-tuple" that consists of the join input tuples,
  rather than projecting the join result columns?
* Invent a concept of "table IDs", and use them instead of table names
* Add a concept of "programs" or "modules"
* Support for persistent tables
