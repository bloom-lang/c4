Parser and lexer:

* Support for parentheses
* Type casts
* Aggregation
* Trinary conditional operator ("?:")
* Allow location specifiers to be attached to constants
* Unicode identifiers and string literals
* Locking / concurrency control
* In string literals, support the "\000" syntax (Octal ASCII
  character) from C89; or perhaps some syntax for specifying Unicode
  code points?
* Error reporting; location of syntax error

Planner:
* Generate implied equalities from the qualifier list
* Avoid Cartesian products, if possible

Executor/Router/Operators:
* Consider writing a specialized allocator for Tuples
* Don't copy WorkItem in the router: have the queue store kind + pointer directly

Broader issues:

* Testing framework
* Error handling
* Add a "$LOCALHOST" variable that expands to the network address of
  the evaluating COL instance
* Invent something similar to makeNode() from Postgres: infer node
  size from node type tag
* Generalize node support from parser/ to nodes/
* Make use of profile-guided optimization with GCC
* Consider caching per-tuple hash code
* Consider using a variable-size length word for ColString: more
  storage-efficient for short strings, which is the common case (or
  special-case just for network input/output?)
* Measure the performance difference between looking up a function
  pointer and doing a table-style lookup (switch statement) for
  functions like datum_equal(), datum_hash()
