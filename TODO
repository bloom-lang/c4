Parser and lexer:

* Support for parentheses
* Type casts
* Aggregation
* Trinary conditional operator ("?:")
* Allow location specifiers to be attached to constants
* Unicode identifiers and string literals
* Make bison parser "pure"
* In string literals, support the "\000" syntax (Octal ASCII
  character) from C89; or perhaps some syntax for specifying Unicode
  code points?
* Error reporting; location of syntax error
* Support for assignments?
* Check for variables that are only referenced once => _

Planner:

* Exploit implied equalities more effectively, suppress duplicate
  predicate evaluations
* Avoid Cartesian products, if possible
* We can skip projection in an operator if no operator in the
  remainder of the op chain requires values that are NOT in the input
  to that operator; e.g. if we do a join and there isn't anything in
  the rest of the op chain that needs a value in the scan_rel, we can
  skip projection on the output of the join
  * This might be complicated by the uniqification of variable names

Executor/Router/Operators:

* Don't copy WorkItem in the router: have the queue store kind + pointer directly
* More efficient joins: the existing approach to joins essentially
  re-materializes intermediate join results. Stems and stairs from
  earlier Eddies work might point toward a better way of doing this.

Network:

* Add an ad-hoc compression method, to avoid resending table names in
  every single packet
  * Have the client and server negotiate that "table 10" means "table
    foo, with schema bar" once, and use that information for the
    remainder of the session
* In network_send(), avoid the ugly conversion from Datum
  representation of tuple's loc spec into C-style string
  representation: either hash directly on the Datum representation, or
  make the Datum->C-style string conversion more efficient
* Add a UDP transport
* Consider adding an SSL-over-TCP transport, and/or secure
  communication in general
* Consider adding a multicast transport?

Data types:

* Consider using a variable-size length word for ColString: more
  storage-efficient for short strings, which is the common case (or
  special-case this just for network format?)
* Support implicit coercions among related types (int2->int4->int8, etc.)
* Replace string location specifier type with an IPv4 endpoint (scalar
  value containing IPv4 address + port)

Tables:

* Invent a concept of "table IDs", and use them instead of table names
* Support for persistent tables, likely using BDB
* Support a more generic table interface
* Consider adding a "regexp" table type: given a string input, parses
  into tuple format by applying a regular expression
* Optimize the hash table implementation

Build system:

* Make use of profile-guided optimization with GCC
* Add a build-time flag to disable assertions

APR:

* Report queue performance issue
* Add support for "apr-config --configure"
* Modify queue type to allow variably-sized queue elements, to avoid
  the need to malloc() small queue messages

Broader issues:

* Testing framework
* Error handling: exceptions via longjmp?
* Add a "$LOCALHOST" variable that expands to the network address of
  the evaluating COL instance
  * Complicated by the fact that a machine can have multiple network
    addresses (one per interface + localhost + IPv4 vs. IPv6, etc.)
* Invent something similar to makeNode() from Postgres: infer node
  size from node type tag
* Consider caching per-tuple hash code
* Change the node system to work with strict aliasing per C99
* Add a concept of "programs" or "modules"
* Implement a simple interactive shell
* Locking / concurrency control

Minor:

* If a fact is defined at node X but has a location specifier for node
  Y, should we send the tuple to node Y, or simply ignore it?
